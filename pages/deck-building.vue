<template>
  <layout-default>
    <div class="d-flex justify-end align-center mb-3">
      <v-btn
        small
        depressed
        @click="upload"
      >
        Upload
      </v-btn>
      <deck-upload-tooltip />
    </div>
    <v-row v-if="decks.length > 0">
      <v-slide-x-reverse-transition
        group
        class="d-flex flex-wrap flex-fill"
      >
        <v-col
          v-for="deck in decks"
          :key="deck.name"
          cols="12"
          sm="4"
          md="3"
          class="d-flex flex-column"
        >
          <v-card
            :to="deck.new ? '/card-list?showSelected' : undefined"
            :disabled="deck.size === 0"
            class="d-flex flex-column flex-fill"
          >
            <v-card-text class="flex-fill">
              {{ deck.name }} ({{ deck.size }})
            </v-card-text>
            <v-card-actions>
              <v-spacer />
              <deck-action-save
                :deck="deck"
                small
              />
              <deck-action-stats
                :deck="deck"
                small
                content-class="ml-2"
              />
              <deck-action-card-draw
                :deck="deck"
                small
                content-class="ml-2"
              />
              <template v-if="!deck.new">
                <v-btn
                  icon
                  small
                  title="Open in Card List"
                  @click="load(deck)"
                >
                  <v-icon small>
                    mdi-upload
                  </v-icon>
                </v-btn>
                <v-speed-dial
                  direction="bottom"
                  transition="slide-y-transition"
                >
                  <template #activator>
                    <v-btn
                      icon
                      small
                      title="Download"
                    >
                      <v-icon small>
                        mdi-download
                      </v-icon>
                    </v-btn>
                  </template>
                  <v-btn
                    icon
                    small
                    title="JSON"
                    @click="downloadJSON(deck)"
                  >
                    <v-icon small>
                      mdi-code-json
                    </v-icon>
                  </v-btn>
                  <v-btn
                    icon
                    small
                    title="CSV"
                    @click="downloadCSV(deck)"
                  >
                    <v-icon small>
                      mdi-file-document
                    </v-icon>
                  </v-btn>
                  <v-btn
                    icon
                    small
                    title="Tabletop Simulator (coming soon)"
                  >
                    <v-icon small>
                      mdi-chess-queen
                    </v-icon>
                  </v-btn>
                </v-speed-dial>
                <v-btn
                  icon
                  small
                  title="Remove"
                  @click="remove(deck)"
                >
                  <v-icon small>
                    mdi-delete
                  </v-icon>
                </v-btn>
              </template>
              <deck-action-clear
                v-else
                small
              />
            </v-card-actions>
          </v-card>
        </v-col>
      </v-slide-x-reverse-transition>
    </v-row>
    <p v-else>
      You have not yet build any decks.
      <nuxt-link
        to="/card-list"
        v-text="'Click here'"
      /> to start building your first deck or use the upload button above.
    </p>
  </layout-default>
</template>

<script>
import { cards } from '~/config/card';
import { download } from '~/mixins/download';
import { defaultDeckName } from '~/store/deckBuilding';

export default {
  name: 'PageDeckBuilding',

  mixins: [
    download
  ],

  head: () => ({
    title: 'Deck Building'
  }),

  computed: {
    decks() {
      const collator = new Intl.Collator(undefined, {
        sensitivity: 'base',
        numeric: true
      });

      return Object.entries(this.$store.state.deckBuilding.decks)
        .map(([
          name,
          cards = {}
        ]) => ({
          name,
          new: name === defaultDeckName,
          size: Object.values(cards).reduce((total, quantity) => total + quantity, 0)
        }))
        .sort((a, b) => (
          b.new - a.new || collator.compare(a.name, b.name)
        ));
    }
  },

  methods: {
    load(deck) {
      if (
        this.$store.getters['deckBuilding/sizeByName']() > 0
        && !confirm('You already have another deck opened. Open this deck instead?')
      ) {
        return;
      }

      this.$store.commit('deckBuilding/load', deck.name);
      this.$store.commit('snackbar/setSuccess', 'Deck opened successfully!');
      this.$router.push('/card-list?showSelected');
    },

    downloadJSON(deck) {
      const data = Buffer.from(
        JSON.stringify({
          name: deck.name,
          cards: this.$store.getters['deckBuilding/deckByName'](deck.name)
        })
      ).toString('base64');

      this.download(`data:application/json;base64,${data}`, `${deck.name}.json`);
    },

    downloadCSV(deck) {
      const collator = new Intl.Collator('en', {
        sensitivity: 'base',
        numeric: true
      });

      const data = Buffer.from(
        [
          '"#","Set","Title","Type","Quantity"',
          ...Object.entries(this.$store.getters['deckBuilding/deckByName'](deck.name))
            .map(([
              id,
              quantity
            ]) => {
              const {
                set,
                title,
                type
              } = cards.find((card) => card.id === id);

              return {
                id,
                set,
                title,
                type,
                quantity
              };
            })
            .sort((a, b) => {
              if (a.type === b.type) {
                return collator.compare(a.id, b.id);
              }

              return collator.compare(a.type, b.type);
            })
            .map(({
              id,
              set,
              title,
              type,
              quantity
            }) => `"${id}","${set}","${title}","${type}","${quantity}"`)
        ].join('\n')
      ).toString('base64');

      this.download(`data:text/csv;base64,${data}`, `${deck.name}.csv`);
    },

    remove(deck) {
      if (!confirm('Are you sure you want to remove this deck?')) {
        return;
      }

      this.$store.commit('deckBuilding/remove', deck.name);
      this.$store.commit('snackbar/setSuccess', 'Deck removed successfully!');
    },

    upload() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'application/json';
      input.multiple = true;
      input.onchange = async (event) => {
        for (const file of event.target.files) {
          try {
            const data = await this.readFile(file);
            const deck = JSON.parse(data);

            if (
              this.$store.getters['deckBuilding/hasName'](deck.name)
              && !confirm(`A deck with name '${deck.name}' already exists. Do you want to overwrite anyways?`)
            ) {
              continue;
            }

            this.$store.commit('deckBuilding/upload', deck);
          } catch (error) {
            console.error(error.message);

            this.$store.commit('snackbar/setError', 'An error occurred while uploading one or more of your decks.');
          }
        }
      };
      input.click();
    },

    /**
     * Read file
     *
     * @param {File} file
     *
     * @returns {Promise<string>}
     */
    readFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => {
          resolve(event.target.result);
        };
        reader.onerror = reject;
        reader.readAsText(file);
      })
    }
  }
}
</script>
